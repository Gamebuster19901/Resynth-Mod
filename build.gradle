//#########################//
//         1.16.3          //
//#########################//

buildscript {
    repositories {
        maven { url = 'https://files.minecraftforge.net/maven' }
        jcenter()
        mavenCentral()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '3.+', changing: true
    }
}

apply plugin: 'net.minecraftforge.gradle'
apply plugin: 'java'
apply plugin: 'eclipse'

//####################################//
//           Config Variables         //
//####################################//

def mod_version = ext.mod_version

/**
 * The specific Minecraft Forge version to use when building
 * the mod. The Built mod jar will only run with this
 * version of Forge or newer.
 */
def forge_version = ext.forge_version

/**
 * The version of Minecraft this Resynth build is for.
 */
def minecraft_version = ext.minecraft_version

def the_one_probe = ext.the_one_probe

def hwyla = ext.hwyla

def enable_the_one_probe = ext.enable_the_one_probe

def enable_hwyla = ext.enable_hwyla

def enable_hwyla_http = ext.enable_hwyla_http

def mod_title = ext.mod_title

def mod_id = ext.mod_id

def mod_author = ext.mod_author

def mod_url = ext.mod_url

/* Additional */

def minecraft_forge_version = "${minecraft_version}-${forge_version}"

def full_title_version = "Resynth-${mod_version}-[Minecraft-Forge-${minecraft_version}]"

def complete_title_version = "Resynth-${mod_version}-[Minecraft-Forge-${minecraft_forge_version}]"

def full_version = "${mod_version}-[${minecraft_version}]"

def complete_version = "${mod_version}-[${minecraft_forge_version}]"

def java_info = (System.getProperty("java.vendor") == "Oracle Corporation" ? "Java(TM)" : "Java-OpenJDK") +
        "-${System.getProperty("java.version")}" + " (${System.getProperty("java.vendor")})"

/**
 * The full name/title to give the mod jar when it's built.
 */
def mod_jar_title = "${full_title_version}.jar"

/**
 * The directory to put the mod jar in when it's built.
 */
def mod_output_folder = project.file("jar")

//####################################//
//                 END                //
//####################################//

//Don't touch...
archivesBaseName = mod_id
version = mod_version
group = "com.ki11erwolf.${archivesBaseName}"

//noinspection GroovyUnusedAssignment
sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = '1.8'

minecraft {
    mappings channel: 'snapshot', version: '20200514-1.16'

    runs {
        client {
            workingDirectory project.file('run')
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'
            property 'forge.logging.console.level', 'debug'
        }

        server {
            workingDirectory project.file('run')
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'
            property 'forge.logging.console.level', 'debug'
        }

        data {
            workingDirectory project.file('run')
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'
            property 'forge.logging.console.level', 'debug'
        }
    }
}

repositories {
    jcenter()
    mavenCentral()

    maven {
        name 'Forge'
        url = 'https://files.minecraftforge.net/maven'
    }

    if (the_one_probe) maven {
        name 'TOP'
        url "https://maven.tterrag.com/"
    }

    if (enable_hwyla) {
        maven {
            name 'Waila'
            url = "https://maven.tehnut.info/"
        }

        if (enable_hwyla_http) maven {
            name 'Waila-Unsecure-HTTP-Protocol'
            url = "http://maven.tehnut.info/"
        }
    }
}

/** Someday... */

//processResources {
//    inputs.property "mod_version", mod_version
//    inputs.property "minecraft_version", minecraft_version
//
//    from(sourceSets.main.resources.srcDirs) {
//        include 'mods.toml'
//        expand 'mod_version': mod_version, 'minecraft_version': minecraft_version
//    }
//    rename '(.+_at.cfg)', 'META-INF/$1'
//}

//##########################################//
//      Forge Version & Dependencies        //
//##########################################//

dependencies {
    //Forge version
    minecraft "net.minecraftforge:forge:${minecraft_version}-${forge_version}"

    //The One Probe version
    if (enable_the_one_probe) {
        compileOnly fg.deobf("mcjty.theoneprobe:${the_one_probe}:api")
        runtimeOnly fg.deobf("mcjty.theoneprobe:${the_one_probe}")
    }

    //Hwyla version
    if (enable_hwyla) {
        compileOnly fg.deobf("mcp.mobius.waila:${hwyla}:api")
        runtimeOnly fg.deobf("mcp.mobius.waila:${hwyla}")
    }
}

jar {
    manifest {
        attributes([
                // Generic - for resynth in general
                "Specification-Title":      mod_id,
                "Specification-Vendor":     mod_author,
                "Specification-Version":    full_version,
                // Specific - for single resynth release
                "Implementation-Title":     mod_title,
                "Implementation-Version":   complete_title_version,
                "Implementation-Vendor":    mod_author,
                "Implementation-Vendor-Id": "${mod_title} (by ${mod_author})",
                "Implementation-Timestamp": new Date().format("dd-MM-yyyy'_'HH:mm:ssZ"),
                "Implementation-URL":       new URL(mod_url),
                // Java
                "Signature-Version":        mod_version,
                "Created-By":               java_info,
                // Custom (Resynth/Forge/Minecraft)
                "Mod-License":              "Apache License, Version 2.0",
        ])
    }
}

/**
 * Always called after the build task has completed.
 *
 * Handles renaming the recently created mod jar, created by the most
 * recent build task, to the more informative modtitle specified. It
 * is also simultaneously moved to a specified directory, preferability
 * one more visibilly accessable.
 *
 * Mod jar title and output directory is specified using `jarTitle`
 * and `jarOutputDir` at top of this file.
 */
task finalizeBuild() {
    //The directory where forge builds and saves the mod jar
    def lookIn = new File("${project.file("build")}/libs/")

    //Defines the specfic mod jar name to be looked for.
    //Later reassigned the value of the mod jar path before move.
    def modjar = "${archivesBaseName}-${mod_version}.jar"

    /**
     * Called and executed last as part of the task,
     * which itself is called after the build process
     * is completed.
     *
     * The Closure that actually handles and coordinates
     * the attempt made to Move & Rename the most recent
     * mod jar build.
     */
    doLast {
        def result = null
        if(tryFindBuiltJar(lookIn, modjar)){
            //If Jar Found
            def finalModJarDest = new File("${mod_output_folder}/${mod_jar_title}")
            cleanAndCreate(mod_output_folder)

            //Store results from the attempted Rename & Move operation
            result = tryRenameAndMove(modjar, finalModJarDest)
            //Check results for success and verify results if successful .
            if(result != true || !finalModJarDest.exists()) {
                //Will default to FAILURE! Could not verify results as successful
                println("[WARNING] Results '${result}' indicate a failure.")
            } else {
                //If Move & Rename results are successful and verified!
                //Also ensure control returns from the task on success, before failing by default.
                println("\n[SUCCESS] Move & Rename operation completed with no known errors!")
                println("\n* * * * ${finalModJarDest} * * * *")
                return //SUCCESS
            }
        }
        //Always defaults to FAILURE unless task is
        //cancelled on SUCCESS with a `return` statement.
        failByDefault(result)
    }

    /// functions ///

    /**
     * Looks for the latest mod jar build in the given directory scope
     * under the given mod jar name.
     *
     * Returns {@code true} if and only if the mod jar was found and the operation
     * can proceed with certainty. Returns {@code false} in all other situations.
     */
    ext.tryFindBuiltJar = { scope, jar ->
        //Begin search for existance of mod jar
        println("\nMod jar build completed by Forge! Looking for mod to rename and move...")
        println("Looking in: \"${scope}\" for \"${jar}\".")

        //Check for mod jar existance, but first
        //Assign full path of jar back into 'modjar' for use later
        def found = (modjar = new File("${scope}/${jar}")).exists()

        //Print and return the search results
        if (!found) {
            println("\n[WARNING] Missing expected mod jar from build! Skipping naming and placement.")
            return false //FAIL
        } else {
            println("\nFound expected mod jar from build! Renaming & moving jar to...")
            println("${mod_output_folder} as ${mod_jar_title}")
            return true //PASS
        }
    }

    /**
     * Ensures that, the given output directory destination
     * is cleaned of all files, and, that the directory
     * actually exists on the filesystem, creating the
     * directory if needed.
     *
     * Cleaning and Creating takes place at the beginning
     * of the task, directly and only after the recently
     * built mod jar is confirmed to exist.
     */
    ext.cleanAndCreate = { dest ->
        println("Cleaning output first...")

        //If final output destination exists, clean with delete
        if(dest.exists())
            dest.delete()
        //before (re)creating destination
        dest.mkdirs()
    }

    /**
     * Called when ready to attempt the actual renaming and
     * moving of the built mod jar.
     *
     * When called, the function delegates the job to
     * 'java.nio.Files#move(src, dest)' and monitors
     * the function call until it returns or an
     * exception is thrown.
     *
     * Function returns {@code true} if and only if both
     * the call returns without an exception, and if the
     * path to the renamed and moved mod jar points to
     * an existing file.
     *
     * If any exception is thrown during the call, it's
     * returned so that it may be rethrown after the task
     * fails gracefully and completely.
     */
    ext.tryRenameAndMove = { modStartDest, modEndDest ->
        try{
            //Attempt Move & Rename operation
            //noinspection UnnecessaryQualifiedReference
            def finalPath = java.nio.file.Files.move(
                    modStartDest.toPath(), modEndDest.toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING
            )
            //Verify mod jar exists at destination path
            return finalPath.toFile().exists()
        } catch (Exception e){
            //Recovery impossible - just catch, log, and return all errors that needs to be dealt with.
            print("\n[WARNING] Move & Rename operation failed with exception: ${e.getClass().getCanonicalName()}")
            return e //Do not throw
        }
    }

    /**
     * Called as soon as, and never before the task is completely declared a failure,
     * when unable to guarantee success - at which point the whole task comes to an
     * end and deems itself a failure by default, prompting the call to this function.
     * The task releases control back directly after this function returns.
     *
     * The result that probably lead to the failure is passed along with the
     * call, typically to pass on any Exceptions and stacktraces
     */
    ext.failByDefault = { result ->
        print("\n[FAILURE] Could not Move & Rename the built mod jar!")
        //Lastly, rethrow the first exception if any only after failure is complete.
        if(result instanceof Exception) { println(); throw result }
        else println(" Result was determined to be '${result}' before failure.")
    }
}

//Captain Obvious strikes again!
build.finalizedBy(finalizeBuild)
